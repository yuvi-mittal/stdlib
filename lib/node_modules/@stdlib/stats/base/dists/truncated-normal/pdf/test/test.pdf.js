/**
* @license Apache-2.0
*
* Copyright (c) 2025 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //
var tape = require('tape');
var path = require('path');
var abs = require('@stdlib/math/base/special/abs');
var PINF = require('@stdlib/constants/float64/pinf');
var NINF = require('@stdlib/constants/float64/ninf');
var isnan = require('@stdlib/math/base/assert/is-nan');
var EPS = require('@stdlib/constants/float64/eps');
var pdf = require('./../lib');


// FIXTURES //
var fixtures = require(path.resolve(__dirname, './fixtures/python/data.json'));


// TESTS //
tape('main export is a function', function test(t) {
	t.ok(true, __filename);
	t.strictEqual(typeof pdf, 'function', 'main export is a function');
	t.end();
});

tape('the function returns NaN if provided NaN as any argument', function test(t) {
	var y;
	y = pdf(NaN, 0.0, 1.0, -1.0, 1.0);
	t.strictEqual(isnan(y), true, 'returns NaN');

	y = pdf(0.5, NaN, 1.0, -1.0, 1.0);
	t.strictEqual(isnan(y), true, 'returns NaN');

	y = pdf(0.5, 0.0, NaN, -1.0, 1.0);
	t.strictEqual(isnan(y), true, 'returns NaN');

	y = pdf(0.5, 0.0, 1.0, NaN, 1.0);
	t.strictEqual(isnan(y), true, 'returns NaN');

	y = pdf(0.5, 0.0, 1.0, -1.0, NaN);
	t.strictEqual(isnan(y), true, 'returns NaN');
	
	t.end();
});

tape('the function returns NaN for invalid sigma values (sigma <= 0)', function test(t) {
	var y;

	y = pdf(0.5, 0.0, 1.0, -1.0, 0.0);
	t.strictEqual(isnan(y), true, 'returns NaN when sigma is 0');

	y = pdf(0.5, 0.0, 1.0, -1.0, -1.0);
	t.strictEqual(isnan(y), true, 'returns NaN when sigma is negative');

	t.end();
});

tape('the function returns NaN when a >= b', function test(t) {
	var y;

	y = pdf(0.5, 1.0, 1.0, 0.0, 1.0);
	t.strictEqual(isnan(y), true, 'returns NaN when a equals b');

	y = pdf(0.5, 2.0, 1.0, 0.0, 1.0);
	t.strictEqual(isnan(y), true, 'returns NaN when a is greater than b');

	t.end();
});

tape('the function returns 0 when x is out of range (x < a or x > b)', function test(t) {
	var y;

	y = pdf(-2.0, 0.0, 1.0, 0.0, 1.0);
	t.strictEqual(y, 0.0, 'returns 0 when x is less than a');

	y = pdf(2.0, 0.0, 1.0, 0.0, 1.0);
	t.strictEqual(y, 0.0, 'returns 0 when x is greater than b');

	t.end();
});

tape('the function evaluates the pdf', function test(t) {
	var expected;
	var sigma;
	var delta;
	var tol;
	var a;
	var b;
	var x;
	var mu;
	var y;
	var i;

	x = fixtures.x;
	mu = fixtures.mu;
	sigma = fixtures.sigma;
	a = fixtures.a;
	b = fixtures.b;
	expected = fixtures.expected;

	for (i = 0; i < x.length; i++) {
		y = pdf(x[i],a[i] ,b[i] , mu[i], sigma[i]);
		if (y === expected[i]) {
			t.equal(y, expected[i], `x: ${x[i]}, mu: ${mu[i]}, sigma: ${sigma[i]}, a: ${a[i]}, b: ${b[i]}, y: ${y}, expected: ${expected[i]}`);
		} else {
			delta = abs(y - expected[i]);
			// tol = EPS * abs(expected[i]);
			tol = 10 * EPS * Math.max(1, abs(expected[i]));
			t.ok(delta <= tol, `within tolerance. x: ${x[i]}, mu: ${mu[i]}, sigma: ${sigma[i]}, a: ${a[i]}, b: ${b[i]}, y: ${y}, expected: ${expected[i]}, Î”: ${delta}, tol: ${tol}`);
		}
	}
	t.end();
});
